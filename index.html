<!DOCTYPE html> 
<html lang="ja"> 
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Face Landmarker 0.1.30</title>

  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three/examples/js/loaders/GLTFLoader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/vision_wasm_internal.js"></script>

  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #liveView {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    video, canvas {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
  <div id="liveView" class="videoView">
    <video id="webcam" autoplay playsinline></video>
    <canvas class="output_canvas" id="output_canvas"></canvas>
    <!-- モデルの位置と回転を設定するHTML属性 -->
    <div id="ar-parameters" data-hat-position="0,0.3,-1.5" data-hat-rotation="0,0,0" 
         data-tonakai-position="0,0.2,-1.5" data-tonakai-rotation="0,0,0"></div>
  </div>

  <script type="module">
    import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const arParameters = document.getElementById('ar-parameters');
    const canvasCtx = canvasElement.getContext('2d');
    let faceLandmarker;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const light = new THREE.AmbientLight(0xffffff, 1);
    scene.add(light);

    let hatModel, tonakaiModel;

    // GLTFLoaderを使用してモデルをロード
    const loader = new THREE.GLTFLoader();
    loader.load('hat.glb', (gltf) => { hatModel = gltf.scene; scene.add(hatModel); });
    loader.load('tonakai.glb', (gltf) => { tonakaiModel = gltf.scene; scene.add(tonakaiModel); });

    // HTML属性の変化を監視してモデルの位置と回転を更新
    const observer = new MutationObserver(() => {
      updateModelTransform(hatModel, 'hat');
      updateModelTransform(tonakaiModel, 'tonakai');
    });

    observer.observe(arParameters, { attributes: true });

    // モデルの位置と回転を更新する関数
    function updateModelTransform(model, type) {
      if (!model) return;
      const positionAttr = arParameters.getAttribute(`data-${type}-position`);
      const rotationAttr = arParameters.getAttribute(`data-${type}-rotation`);

      if (positionAttr) {
        const [x, y, z] = positionAttr.split(',').map(Number);
        model.position.set(x, y, z);
      }

      if (rotationAttr) {
        const [rx, ry, rz] = rotationAttr.split(',').map(Number);
        model.rotation.set(rx, ry, rz);
      }
    }

    async function setupFaceLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        outputFaceBlendshapes: true,
        runningMode: "VIDEO",
        numFaces: 5
      });

      navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } })
        .then((stream) => {
          videoElement.srcObject = stream;
          videoElement.addEventListener("loadeddata", predictWebcam);
        })
        .catch((err) => console.error("カメラ取得エラー:", err));
    }

    async function predictWebcam() {
      if (faceLandmarker && videoElement.readyState >= 2) {
        const results = await faceLandmarker.detectForVideo(videoElement, performance.now());
        updateModels(results);
      }
      requestAnimationFrame(predictWebcam);
    }

    function updateModels(results) {
      if (!results.faceLandmarks) return;

      results.faceLandmarks.forEach((landmarks, index) => {
        if (index === 0 && hatModel) updateModelTransform(hatModel, 'hat');
        if (index === 1 && tonakaiModel) updateModelTransform(tonakaiModel, 'tonakai');
      });

      renderer.render(scene, camera);
    }

    setupFaceLandmarker();
  </script>
</body>
</html>
