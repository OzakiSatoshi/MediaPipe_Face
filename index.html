<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  <title>Face Landmarker 0.1.0</title>

  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
  <!-- WASM用のスクリプトを追加 -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm/vision_wasm_internal.js"></script>
</head>
<body>
  <h1>Face Landmark Detection with MediaPipe</h1>

  <section id="demos">
    <div id="liveView" class="videoView">
      <div style="position: relative;">
        <video id="webcam" autoplay playsinline style="position: absolute; width: 640px; height: 480px;"></video>
        <canvas class="output_canvas" id="output_canvas" width="640" height="480" style="position: absolute; left: 0px; top: 0px;"></canvas>
      </div>
    </div>
    <div class="blend-shapes">
      <ul class="blend-shapes-list" id="video-blend-shapes"></ul>
    </div>
  </section>

  <script type="module">
    import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

    const videoElement = document.getElementById('webcam');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    let faceLandmarker;
    let runningMode = "VIDEO";
    let lastVideoTime = -1;

    async function setupFaceLandmarker() {
      const vision = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );

      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
        baseOptions: {
          modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
          delegate: "GPU"
        },
        outputFaceBlendshapes: true,
        runningMode: runningMode,
        numFaces: 1
      });

      // カメラの設定
      const constraints = {
        video: {
          width: 640,
          height: 480
        }
      };

      navigator.mediaDevices.getUserMedia(constraints)
        .then((stream) => {
          videoElement.srcObject = stream;
          videoElement.addEventListener("loadeddata", predictWebcam);
        })
        .catch((err) => {
          console.error("カメラの取得に失敗しました:", err);
        });
    }

    let lastVideoTimestamp = 0;
    async function predictWebcam() {
      if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await faceLandmarker.setOptions({ runningMode: "VIDEO" });
      }
      let startTimeMs = performance.now();

      if (lastVideoTime !== videoElement.currentTime) {
        lastVideoTime = videoElement.currentTime;
        const results = await faceLandmarker.detectForVideo(videoElement, startTimeMs);
        displayResults(results);
      }

      window.requestAnimationFrame(predictWebcam);
    }

    function displayResults(results) {
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

      if (results.faceLandmarks) {
        for (const landmarks of results.faceLandmarks) {
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {
            color: "#C0C0C070",
            lineWidth: 1
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {
            color: "#FF3030"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, {
            color: "#FF3030"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, {
            color: "#FF3030"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {
            color: "#30FF30"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, {
            color: "#30FF30"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, {
            color: "#30FF30"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {
            color: "#E0E0E0"
          });
          drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {
            color: "#E0E0E0"
          });
        }
      }
      canvasCtx.restore();
    }

    setupFaceLandmarker();
  </script>
</body>
</html>